{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/common/utils.ts", "../src/useCombinedRefs.ts", "../src/useObjectPropEffect.ts", "../src/env.ts"],
  "sourcesContent": ["import React, { useEffect } from 'react';\nimport type { CSSProperties } from 'react';\nimport type {\n  StreamTypes,\n  PlaybackTypes,\n  CmcdTypes,\n  MaxResolutionValue,\n  MinResolutionValue,\n  RenditionOrderValue,\n} from '@mux/playback-core';\nimport { MaxResolution, MinResolution, RenditionOrder } from '@mux/playback-core';\nimport { MediaError } from '@mux/mux-player';\nimport type MuxPlayerElement from '@mux/mux-player';\nimport type { Tokens, MuxPlayerElementEventMap } from '@mux/mux-player';\nimport { toNativeProps } from './common/utils';\nimport { useRef } from 'react';\nimport { useCombinedRefs } from './useCombinedRefs';\nimport useObjectPropEffect, { defaultHasChanged } from './useObjectPropEffect';\nimport { getPlayerVersion } from './env';\n\nexport { MediaError, MaxResolution, MinResolution, RenditionOrder };\n\ntype ValueOf<T> = T[keyof T];\ninterface GenericEventListener<T extends Event = CustomEvent> {\n  (evt: T): void;\n}\n\nexport type MuxPlayerRefAttributes = MuxPlayerElement;\ntype VideoApiAttributes = {\n  currentTime: number;\n  volume: number;\n  paused: boolean;\n  src: string | null;\n  poster: string;\n  playbackRate: number;\n  playsInline: boolean;\n  preload: string;\n  crossOrigin: string;\n  autoPlay: boolean | string;\n  loop: boolean;\n  muted: boolean;\n  style: CSSProperties;\n};\n\ntype MuxMediaPropTypes = {\n  audio: boolean;\n  //  envKey: Options[\"data\"][\"env_key\"];\n  envKey: string;\n  // debug: Options[\"debug\"] & Hls[\"config\"][\"debug\"];\n  debug: boolean;\n  disableCookies: boolean;\n  disablePictureInPicture?: boolean;\n  // metadata: Partial<Options[\"data\"]>;\n  metadata: { [k: string]: any };\n  extraSourceParams: Record<string, any>;\n  _hlsConfig: MuxPlayerElement['_hlsConfig'];\n  beaconCollectionDomain: string;\n  customDomain: string;\n  playbackId: string;\n  preferPlayback: ValueOf<PlaybackTypes> | undefined;\n  // NOTE: Explicitly adding deprecated values here for now to avoid fully breaking changes in TS envs (CJP)\n  streamType: ValueOf<StreamTypes> | 'll-live' | 'live:dvr' | 'll-live:dvr';\n  defaultStreamType: ValueOf<StreamTypes>;\n  targetLiveWindow: number;\n  startTime: number;\n  storyboardSrc: string;\n  preferCmcd: ValueOf<CmcdTypes> | undefined;\n  children?: React.ReactNode;\n};\n\nexport type MuxPlayerProps = {\n  className?: string;\n  hotkeys?: string;\n  nohotkeys?: boolean;\n  defaultHiddenCaptions?: boolean;\n  playerSoftwareVersion?: string;\n  playerSoftwareName?: string;\n  forwardSeekOffset?: number;\n  backwardSeekOffset?: number;\n  maxResolution?: MaxResolutionValue;\n  minResolution?: MinResolutionValue;\n  renditionOrder?: RenditionOrderValue;\n  metadataVideoId?: string;\n  metadataVideoTitle?: string;\n  metadataViewerUserId?: string;\n  primaryColor?: string;\n  secondaryColor?: string;\n  accentColor?: string;\n  placeholder?: string;\n  playbackRates?: number[];\n  defaultShowRemainingTime?: boolean;\n  defaultDuration?: number;\n  noVolumePref?: boolean;\n  thumbnailTime?: number;\n  title?: string;\n  tokens?: Tokens;\n  theme?: string;\n  themeProps?: { [k: string]: any };\n  onAbort?: GenericEventListener<MuxPlayerElementEventMap['abort']>;\n  onCanPlay?: GenericEventListener<MuxPlayerElementEventMap['canplay']>;\n  onCanPlayThrough?: GenericEventListener<MuxPlayerElementEventMap['canplaythrough']>;\n  onEmptied?: GenericEventListener<MuxPlayerElementEventMap['emptied']>;\n  onLoadStart?: GenericEventListener<MuxPlayerElementEventMap['loadstart']>;\n  onLoadedData?: GenericEventListener<MuxPlayerElementEventMap['loadeddata']>;\n  onLoadedMetadata?: GenericEventListener<MuxPlayerElementEventMap['loadedmetadata']>;\n  onProgress?: GenericEventListener<MuxPlayerElementEventMap['progress']>;\n  onDurationChange?: GenericEventListener<MuxPlayerElementEventMap['durationchange']>;\n  onVolumeChange?: GenericEventListener<MuxPlayerElementEventMap['volumechange']>;\n  onRateChange?: GenericEventListener<MuxPlayerElementEventMap['ratechange']>;\n  onResize?: GenericEventListener<MuxPlayerElementEventMap['resize']>;\n  onWaiting?: GenericEventListener<MuxPlayerElementEventMap['waiting']>;\n  onPlay?: GenericEventListener<MuxPlayerElementEventMap['play']>;\n  onPlaying?: GenericEventListener<MuxPlayerElementEventMap['playing']>;\n  onTimeUpdate?: GenericEventListener<MuxPlayerElementEventMap['timeupdate']>;\n  onPause?: GenericEventListener<MuxPlayerElementEventMap['pause']>;\n  onSeeking?: GenericEventListener<MuxPlayerElementEventMap['seeking']>;\n  onSeeked?: GenericEventListener<MuxPlayerElementEventMap['seeked']>;\n  onStalled?: GenericEventListener<MuxPlayerElementEventMap['stalled']>;\n  onSuspend?: GenericEventListener<MuxPlayerElementEventMap['suspend']>;\n  onEnded?: GenericEventListener<MuxPlayerElementEventMap['ended']>;\n  onError?: GenericEventListener<MuxPlayerElementEventMap['error']>;\n  onCuePointChange?: GenericEventListener<MuxPlayerElementEventMap['cuepointchange']>;\n  onCuePointsChange?: GenericEventListener<MuxPlayerElementEventMap['cuepointschange']>;\n  // onPlayerReady?: EventListener;\n} & Partial<MuxMediaPropTypes> &\n  Partial<VideoApiAttributes>;\n\nconst MuxPlayerInternal = React.forwardRef<MuxPlayerRefAttributes, MuxPlayerProps>(({ children, ...props }, ref) => {\n  return React.createElement('mux-player', toNativeProps({ ...props, ref }), children);\n});\n\nconst useEventCallbackEffect = <K extends keyof MuxPlayerElementEventMap>(\n  type: K,\n  ref: // | ((instance: EventTarget | null) => void)\n  React.MutableRefObject<MuxPlayerElement | null> | null | undefined,\n  callback: GenericEventListener<MuxPlayerElementEventMap[K]> | undefined\n) => {\n  return useEffect(() => {\n    const eventTarget = ref?.current;\n    if (!eventTarget || !callback) return;\n    eventTarget.addEventListener(type, callback);\n    return () => {\n      eventTarget.removeEventListener(type, callback);\n    };\n  }, [ref?.current, callback]);\n};\n\nconst usePlayer = (\n  ref: // | ((instance: EventTarget | null) => void)\n  React.MutableRefObject<MuxPlayerElement | null> | null | undefined,\n  props: MuxPlayerProps\n) => {\n  const {\n    onAbort,\n    onCanPlay,\n    onCanPlayThrough,\n    onEmptied,\n    onLoadStart,\n    onLoadedData,\n    onLoadedMetadata,\n    onProgress,\n    onDurationChange,\n    onVolumeChange,\n    onRateChange,\n    onResize,\n    onWaiting,\n    onPlay,\n    onPlaying,\n    onTimeUpdate,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onStalled,\n    onSuspend,\n    onEnded,\n    onError,\n    onCuePointChange,\n    onCuePointsChange,\n    // onPlayerReady,\n    metadata,\n    tokens,\n    paused,\n    playbackId,\n    playbackRates,\n    currentTime,\n    themeProps,\n    extraSourceParams,\n    _hlsConfig,\n    ...remainingProps\n  } = props;\n  useObjectPropEffect('playbackRates', playbackRates, ref);\n  useObjectPropEffect('metadata', metadata, ref);\n  useObjectPropEffect('extraSourceParams', extraSourceParams, ref);\n  useObjectPropEffect('_hlsConfig', _hlsConfig, ref);\n  useObjectPropEffect('themeProps', themeProps, ref);\n  useObjectPropEffect('tokens', tokens, ref);\n  useObjectPropEffect('playbackId', playbackId, ref);\n  useObjectPropEffect(\n    'paused',\n    paused,\n    ref,\n    (playerEl: HTMLMediaElement, pausedVal?: boolean) => {\n      if (pausedVal == null) return;\n      if (pausedVal) {\n        playerEl.pause();\n      } else {\n        playerEl.play();\n      }\n    },\n    (playerEl, value, propName) => {\n      if (playerEl.hasAttribute('autoplay') && !playerEl.hasPlayed) {\n        return false;\n      }\n      return defaultHasChanged(playerEl, value, propName);\n    }\n  );\n  useObjectPropEffect('currentTime', currentTime, ref, (playerEl: HTMLMediaElement, currentTimeVal?: number) => {\n    if (currentTimeVal == null) return;\n    playerEl.currentTime = currentTimeVal;\n  });\n  useEventCallbackEffect('abort', ref, onAbort);\n  useEventCallbackEffect('canplay', ref, onCanPlay);\n  useEventCallbackEffect('canplaythrough', ref, onCanPlayThrough);\n  useEventCallbackEffect('emptied', ref, onEmptied);\n  useEventCallbackEffect('loadstart', ref, onLoadStart);\n  useEventCallbackEffect('loadeddata', ref, onLoadedData);\n  useEventCallbackEffect('loadedmetadata', ref, onLoadedMetadata);\n  useEventCallbackEffect('progress', ref, onProgress);\n  useEventCallbackEffect('durationchange', ref, onDurationChange);\n  useEventCallbackEffect('volumechange', ref, onVolumeChange);\n  useEventCallbackEffect('ratechange', ref, onRateChange);\n  useEventCallbackEffect('resize', ref, onResize);\n  useEventCallbackEffect('waiting', ref, onWaiting);\n  useEventCallbackEffect('play', ref, onPlay);\n  useEventCallbackEffect('playing', ref, onPlaying);\n  useEventCallbackEffect('timeupdate', ref, onTimeUpdate);\n  useEventCallbackEffect('pause', ref, onPause);\n  useEventCallbackEffect('seeking', ref, onSeeking);\n  useEventCallbackEffect('seeked', ref, onSeeked);\n  useEventCallbackEffect('stalled', ref, onStalled);\n  useEventCallbackEffect('suspend', ref, onSuspend);\n  useEventCallbackEffect('ended', ref, onEnded);\n  useEventCallbackEffect('error', ref, onError);\n  useEventCallbackEffect('cuepointchange', ref, onCuePointChange);\n  useEventCallbackEffect('cuepointschange', ref, onCuePointsChange);\n  // useEventCallbackEffect('playerready', ref, onPlayerReady);\n  return [remainingProps];\n};\n\nconst playerSoftwareVersion = getPlayerVersion();\nconst playerSoftwareName = 'mux-player-react';\n\nconst MuxPlayer = React.forwardRef<\n  MuxPlayerRefAttributes,\n  Omit<MuxPlayerProps, 'playerSoftwareVersion' | 'playerSoftwareName'>\n>((props, ref) => {\n  const innerPlayerRef = useRef<MuxPlayerElement>(null);\n  const playerRef = useCombinedRefs(innerPlayerRef, ref);\n  const [remainingProps] = usePlayer(innerPlayerRef, props);\n\n  return (\n    <MuxPlayerInternal\n      /** @TODO Fix types relationships (CJP) */\n      ref={playerRef as typeof innerPlayerRef}\n      playerSoftwareName={playerSoftwareName}\n      playerSoftwareVersion={playerSoftwareVersion}\n      {...remainingProps}\n    />\n  );\n});\n\nexport default MuxPlayer;\n", "// NOTE: As a forward-looking implementation, we may want to assume\n// prop names -> attribute names is always a simple name.toLowerCase()\n// and provide a mechanism for passing in per-component overrides for\n// e.g. kebab cases, as that's the way React/Preact handles these. (CJP)\nconst ReactPropToAttrNameMap = {\n  className: 'class',\n  classname: 'class',\n  htmlFor: 'for',\n  crossOrigin: 'crossorigin',\n  viewBox: 'viewBox',\n  playsInline: 'playsinline',\n  autoPlay: 'autoplay',\n  playbackRate: 'playbackrate',\n};\n\ntype KeyTypes = string | number | symbol;\ntype Maybe<T> = T | null | undefined;\n\nexport const isNil = (x: unknown): x is null | undefined => x == undefined;\n\n// Type Guard to determine if a given key is actually a key of some object of type T\nexport const isKeyOf = <T extends {} = any>(k: KeyTypes, o: Maybe<T>): k is keyof T => {\n  if (isNil(o)) return false;\n  return k in o;\n};\n\nconst toKebabCase = (string: string) => string.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n\nexport const toNativeAttrName = (propName: string, propValue: any): string | undefined => {\n  if (typeof propValue === 'boolean' && !propValue) return undefined;\n  if (isKeyOf(propName, ReactPropToAttrNameMap)) return ReactPropToAttrNameMap[propName];\n  if (typeof propValue == undefined) return undefined;\n  if (/[A-Z]/.test(propName)) return toKebabCase(propName);\n  return propName;\n};\nexport const toStyleAttr = <T>(x: T) => x;\n\nexport const toNativeAttrValue = (propValue: any, propName: string) => {\n  if (typeof propValue === 'boolean') return '';\n  return propValue;\n};\n\nexport const toNativeProps = (props = {}) => {\n  return Object.entries(props).reduce<{ [k: string]: string }>((transformedProps, [propName, propValue]) => {\n    const attrName = toNativeAttrName(propName, propValue);\n\n    // prop was stripped. Don't add.\n    if (!attrName) {\n      return transformedProps;\n    }\n\n    const attrValue = toNativeAttrValue(propValue, propName);\n    transformedProps[attrName] = attrValue;\n    return transformedProps;\n  }, {});\n};\n", "import { useEffect, useRef } from 'react';\nimport type { MutableRefObject, ForwardedRef } from 'react';\n\ntype Maybe<T> = T | null | undefined;\ntype RefCb<T> = (instance: Maybe<T>) => void;\ntype RefObj<T> = MutableRefObject<Maybe<T>>;\ntype RefTypes<T> = RefObj<T> | RefCb<T> | ForwardedRef<T>;\ninterface useCombinedRefs {\n  <T>(...refs: Maybe<RefTypes<T>>[]): RefObj<T>;\n}\n\nexport const useCombinedRefs: useCombinedRefs = (...refs) => {\n  const targetRef = useRef(null);\n\n  useEffect(() => {\n    refs.forEach((ref) => {\n      if (!ref) return;\n\n      if (typeof ref === 'function') {\n        ref(targetRef.current);\n      } else {\n        ref.current = targetRef.current;\n      }\n    });\n  }, [refs]);\n\n  return targetRef;\n};\n\n// TS assumed default export was interface def instead of function value (CJP)\nconst defaultUseCombinedRefs = useCombinedRefs;\nexport default defaultUseCombinedRefs;\n", "import { useEffect } from 'react';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Slightly modified version of React's shallowEqual, with optimizations for Arrays\n * so we may treat them specifically as unequal if they are not a) both arrays\n * or b) don't contain the same (shallowly compared) elements.\n */\nconst shallowEqual = (objA: any, objB: any): boolean => {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  if (Array.isArray(objA)) {\n    // Early \"cheap\" array compares\n    if (!Array.isArray(objB) || objA.length !== objB.length) return false;\n    // Shallow compare for arrays\n    return objA.some((vVal, i) => objB[i] === vVal);\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const defaultHasChanged = (obj: any, v: any, k: string) => {\n  return !shallowEqual(v, obj[k]);\n};\n\nconst defaultUpdateValue = (obj: any, v: any, k: string) => {\n  obj[k] = v;\n};\n\nexport const useObjectPropEffect = <T extends { [k: string]: any }, V>(\n  propName: string,\n  propValue: V | null | undefined,\n  ref: React.MutableRefObject<T | null> | null | undefined,\n  updateValue = defaultUpdateValue,\n  hasChanged = defaultHasChanged\n) => {\n  return useEffect(() => {\n    const obj = ref?.current;\n    if (!obj) return;\n    if (!hasChanged(obj, propValue, propName)) return;\n    updateValue(obj, propValue, propName);\n  }, [ref?.current, propValue]);\n};\n\nexport default useObjectPropEffect;\n", "const getEnvPlayerVersion = () => {\n  try {\n    // @ts-ignore\n    return PLAYER_VERSION as string;\n  } catch {}\n  return 'UNKNOWN';\n};\n\nconst player_version: string = getEnvPlayerVersion();\n\nexport const getPlayerVersion = () => player_version;\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "src_default", "__toCommonJS", "import_react", "import_playback_core", "import_mux_player", "ReactPropToAttrNameMap", "isNil", "x", "isKeyOf", "k", "o", "toKebabCase", "string", "match", "toNativeAttrName", "propName", "propValue", "toNativeAttrValue", "propValue", "propName", "toNativeProps", "props", "transformedProps", "attrName", "toNativeAttrName", "attrValue", "import_react", "import_react", "useCombinedRefs", "refs", "targetRef", "ref", "import_react", "hasOwnProperty", "shallowEqual", "objA", "objB", "vVal", "i", "keysA", "keysB", "defaultHasChanged", "obj", "v", "k", "defaultUpdateValue", "useObjectPropEffect", "propName", "propValue", "ref", "updateValue", "hasChanged", "useObjectPropEffect_default", "getEnvPlayerVersion", "player_version", "getPlayerVersion", "MuxPlayerInternal", "React", "children", "props", "ref", "toNativeProps", "useEventCallbackEffect", "type", "callback", "eventTarget", "usePlayer", "onAbort", "onCanPlay", "onCanPlayThrough", "onEmptied", "onLoadStart", "onLoadedData", "onLoadedMetadata", "onProgress", "onDurationChange", "onVolumeChange", "onRateChange", "onResize", "onWaiting", "onPlay", "onPlaying", "onTimeUpdate", "onPause", "onSeeking", "onSeeked", "onStalled", "onSuspend", "onEnded", "onError", "onCuePointChange", "onCuePointsChange", "metadata", "tokens", "paused", "playbackId", "playbackRates", "currentTime", "themeProps", "extraSourceParams", "_hlsConfig", "remainingProps", "useObjectPropEffect_default", "playerEl", "pausedVal", "value", "propName", "defaultHasChanged", "currentTimeVal", "playerSoftwareVersion", "getPlayerVersion", "playerSoftwareName", "MuxPlayer", "innerPlayerRef", "playerRef", "useCombinedRefs", "src_default"]
}
