/// <reference path="mux-embed.d.ts" />
import mux from 'mux-embed';
import Hls from './hls';
import { HlsInterface } from './hls';
import { MediaError } from './errors';
import { addTextTrack, removeTextTrack, addCuePoints, getCuePoints, getActiveCuePoint, setupCuePoints, getCuePointsTrack } from './text-tracks';
import { getStartDate, getCurrentPdt } from './pdt';
import { ValueOf, PlaybackCore, MuxMediaProps, MuxMediaPropsInternal, MaxResolutionValue, MinResolutionValue, RenditionOrderValue } from './types';
import { StreamTypes, MediaTypes } from './types';
export { mux, Hls, MediaError, addTextTrack, removeTextTrack, addCuePoints, getCuePoints, getActiveCuePoint, getCuePointsTrack, setupCuePoints, getStartDate, getCurrentPdt, };
export * from './types';
export declare const getMediaPlaylistLinesFromMultivariantPlaylistSrc: (src: string) => Promise<string[]>;
export declare const getStreamInfoFromPlaylistLines: (playlistLines: string[]) => {
    streamType: "on-demand" | "live";
    targetLiveWindow: number;
    liveEdgeStartOffset: number | undefined;
};
export declare const getStreamInfoFromSrcAndType: (src: string, type?: MediaTypes | '') => Promise<{
    streamType: "on-demand" | "live";
    targetLiveWindow: number;
    liveEdgeStartOffset: number | undefined;
} | {
    streamType: undefined;
    targetLiveWindow: undefined;
    liveEdgeStartOffset: undefined;
}>;
export declare const updateStreamInfoFromSrc: (src: string, mediaEl: HTMLMediaElement, type?: MediaTypes | '') => Promise<void>;
export declare const getStreamInfoFromHlsjsLevelDetails: (levelDetails: any) => {
    streamType: "on-demand" | "live";
    targetLiveWindow: number;
    liveEdgeStartOffset: number | undefined;
    lowLatency: boolean;
};
export declare const updateStreamInfoFromHlsjsLevelDetails: (levelDetails: any, mediaEl: HTMLMediaElement, hls: Pick<Hls, 'config' | 'userConfig' | 'liveSyncPosition'>) => void;
export declare const muxMediaState: WeakMap<HTMLMediaElement, Partial<MuxMediaProps> & {
    seekable?: TimeRanges;
    liveEdgeStartOffset?: number;
}>;
export declare const generatePlayerInitTime: () => number;
export declare const generateUUID: () => string;
type MuxVideoURLProps = Partial<{
    playbackId: string;
    customDomain: string;
    maxResolution: MaxResolutionValue;
    minResolution: MinResolutionValue;
    renditionOrder: RenditionOrderValue;
    tokens: Partial<{
        playback: string;
        storyboard: string;
        thumbnail: string;
    }>;
    extraSourceParams: Record<string, any>;
}>;
export declare const toMuxVideoURL: ({ playbackId: playbackIdWithParams, customDomain: domain, maxResolution, minResolution, renditionOrder, tokens: { playback: token }, extraSourceParams, }?: MuxVideoURLProps) => string | undefined;
export declare const getError: (mediaEl: HTMLMediaElement) => globalThis.MediaError | (globalThis.MediaError & MediaError) | null | undefined;
export declare const getStreamType: (mediaEl: HTMLMediaElement) => ValueOf<StreamTypes>;
export declare const getTargetLiveWindow: (mediaEl: HTMLMediaElement) => number;
export declare const getSeekable: (mediaEl: HTMLMediaElement) => TimeRanges;
export declare const getLiveEdgeStart: (mediaEl: HTMLMediaElement) => number;
export declare const isPseudoEnded: (mediaEl: HTMLMediaElement, moe?: number) => boolean;
export declare const isStuckOnLastFragment: (mediaEl: HTMLMediaElement, hls?: Pick<Hls, 
/** Should we add audio fragments logic here, too? (CJP) */
'levels' | 'currentLevel'>) => boolean | undefined;
export declare const getEnded: (mediaEl: HTMLMediaElement, hls?: Pick<Hls, 
/** Should we add audio fragments logic here, too? (CJP) */
'levels' | 'currentLevel'>) => boolean;
export declare const initialize: (props: Partial<MuxMediaPropsInternal>, mediaEl: HTMLMediaElement, core?: PlaybackCore) => {
    engine: Hls | undefined;
    setAutoplay: (newAutoplay?: import("./types").Autoplay | undefined) => void;
    setPreload: (val?: "" | "none" | "metadata" | "auto" | undefined) => void;
};
export declare const teardown: (mediaEl?: HTMLMediaElement | null, core?: PlaybackCore) => void;
export declare const setupHls: (props: Partial<Pick<MuxMediaPropsInternal, 'debug' | 'streamType' | 'type' | 'startTime' | 'metadata' | 'preferCmcd' | '_hlsConfig'>>, mediaEl: Pick<HTMLMediaElement, 'canPlayType'>) => Hls | undefined;
export declare const getStreamTypeConfig: (streamType?: ValueOf<StreamTypes>) => {};
export declare const isMuxVideoSrc: ({ playbackId, src, customDomain, }: Partial<Pick<MuxMediaPropsInternal, 'playbackId' | 'src' | 'customDomain'>>) => boolean;
export declare const setupMux: (props: Partial<Pick<MuxMediaPropsInternal, 'envKey' | 'playerInitTime' | 'beaconCollectionDomain' | 'errorTranslator' | 'metadata' | 'debug' | 'playerSoftwareName' | 'playerSoftwareVersion' | 'playbackId' | 'src' | 'customDomain' | 'disableCookies'>>, mediaEl: HTMLMediaElement, hlsjs?: HlsInterface) => void;
export declare const loadMedia: (props: Partial<Pick<MuxMediaProps, 'preferPlayback' | 'src' | 'type' | 'startTime' | 'streamType' | 'autoplay'>>, mediaEl: HTMLMediaElement, hls?: Pick<Hls, 'config' | 'on' | 'once' | 'off' | 'trigger' | 'startLoad' | 'stopLoad' | 'recoverMediaError' | 'destroy' | 'loadSource' | 'attachMedia' | 'liveSyncPosition' | 'subtitleTracks' | 'subtitleTrack' | 'userConfig' | 'audioTrack' | 'audioTracks' | 'autoLevelEnabled' | 'nextLevel' | 'levels' | 'currentLevel'>) => void;
