// File generated from our OpenAPI spec by Stainless.
import { APIResource } from '@mux/mux-node/resource';
import { isRequestOptions } from '@mux/mux-node/core';
import * as LiveStreamsAPI from '@mux/mux-node/resources/video/live-streams';
import { BasePage } from '@mux/mux-node/pagination';
export class LiveStreams extends APIResource {
    /**
     * Creates a new live stream. Once created, an encoder can connect to Mux via the
     * specified stream key and begin streaming to an audience.
     */
    create(body, options) {
        return this._client.post('/video/v1/live-streams', { body, ...options })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Retrieves the details of a live stream that has previously been created. Supply
     * the unique live stream ID that was returned from your previous request, and Mux
     * will return the corresponding live stream information. The same information is
     * returned when creating a live stream.
     */
    retrieve(liveStreamId, options) {
        return this._client.get(`/video/v1/live-streams/${liveStreamId}`, options)._thenUnwrap((obj) => obj.data);
    }
    /**
     * Updates the parameters of a previously-created live stream. This currently
     * supports a subset of variables. Supply the live stream ID and the updated
     * parameters and Mux will return the corresponding live stream information. The
     * information returned will be the same after update as for subsequent get live
     * stream requests.
     */
    update(liveStreamId, body, options) {
        return this._client.patch(`/video/v1/live-streams/${liveStreamId}`, { body, ...options })._thenUnwrap((obj) => obj.data);
    }
    list(query = {}, options) {
        if (isRequestOptions(query)) {
            return this.list({}, query);
        }
        return this._client.getAPIList('/video/v1/live-streams', LiveStreamsBasePage, { query, ...options });
    }
    /**
     * Deletes a live stream from the current environment. If the live stream is
     * currently active and being streamed to, ingest will be terminated and the
     * encoder will be disconnected.
     */
    delete(liveStreamId, options) {
        return this._client.delete(`/video/v1/live-streams/${liveStreamId}`, {
            ...options,
            headers: { Accept: '*/*', ...options?.headers },
        });
    }
    /**
     * (Optional) End the live stream recording immediately instead of waiting for the
     * reconnect_window. `EXT-X-ENDLIST` tag is added to the HLS manifest which
     * notifies the player that this live stream is over.
     *
     * Mux does not close the encoder connection immediately. Encoders are often
     * configured to re-establish connections immediately which would result in a new
     * recorded asset. For this reason, Mux waits for 60s before closing the connection
     * with the encoder. This 60s timeframe is meant to give encoder operators a chance
     * to disconnect from their end.
     */
    complete(liveStreamId, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/complete`, {
            ...options,
            headers: { Accept: '*/*', ...options?.headers },
        });
    }
    /**
     * Create a new playback ID for this live stream, through which a viewer can watch
     * the streamed content of the live stream.
     */
    createPlaybackId(liveStreamId, body, options) {
        return this._client.post(`/video/v1/live-streams/${liveStreamId}/playback-ids`, {
            body,
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Create a simulcast target for the parent live stream. Simulcast target can only
     * be created when the parent live stream is in idle state. Only one simulcast
     * target can be created at a time with this API.
     */
    createSimulcastTarget(liveStreamId, body, options) {
        return this._client.post(`/video/v1/live-streams/${liveStreamId}/simulcast-targets`, {
            body,
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Deletes the playback ID for the live stream. This will not disable ingest (as
     * the live stream still exists). New attempts to play back the live stream will
     * fail immediately. However, current viewers will be able to continue watching the
     * stream for some period of time.
     */
    deletePlaybackId(liveStreamId, playbackId, options) {
        return this._client.delete(`/video/v1/live-streams/${liveStreamId}/playback-ids/${playbackId}`, {
            ...options,
            headers: { Accept: '*/*', ...options?.headers },
        });
    }
    /**
     * Delete the simulcast target using the simulcast target ID returned when creating
     * the simulcast target. Simulcast Target can only be deleted when the parent live
     * stream is in idle state.
     */
    deleteSimulcastTarget(liveStreamId, simulcastTargetId, options) {
        return this._client.delete(`/video/v1/live-streams/${liveStreamId}/simulcast-targets/${simulcastTargetId}`, { ...options, headers: { Accept: '*/*', ...options?.headers } });
    }
    /**
     * Disables a live stream, making it reject incoming RTMP streams until re-enabled.
     * The API also ends the live stream recording immediately when active. Ending the
     * live stream recording adds the `EXT-X-ENDLIST` tag to the HLS manifest which
     * notifies the player that this live stream is over.
     *
     * Mux also closes the encoder connection immediately. Any attempt from the encoder
     * to re-establish connection will fail till the live stream is re-enabled.
     */
    disable(liveStreamId, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/disable`, {
            ...options,
            headers: { Accept: '*/*', ...options?.headers },
        });
    }
    /**
     * Enables a live stream, allowing it to accept an incoming RTMP stream.
     */
    enable(liveStreamId, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/enable`, {
            ...options,
            headers: { Accept: '*/*', ...options?.headers },
        });
    }
    /**
     * Reset a live stream key if you want to immediately stop the current stream key
     * from working and create a new stream key that can be used for future broadcasts.
     */
    resetStreamKey(liveStreamId, options) {
        return this._client.post(`/video/v1/live-streams/${liveStreamId}/reset-stream-key`, options)._thenUnwrap((obj) => obj.data);
    }
    /**
     * Fetches information about a live stream's playback ID, through which a viewer
     * can watch the streamed content from this live stream.
     */
    retrievePlaybackId(liveStreamId, playbackId, options) {
        return this._client.get(`/video/v1/live-streams/${liveStreamId}/playback-ids/${playbackId}`, options)._thenUnwrap((obj) => obj.data);
    }
    /**
     * Retrieves the details of the simulcast target created for the parent live
     * stream. Supply the unique live stream ID and simulcast target ID that was
     * returned in the response of create simulcast target request, and Mux will return
     * the corresponding information.
     */
    retrieveSimulcastTarget(liveStreamId, simulcastTargetId, options) {
        return this._client.get(`/video/v1/live-streams/${liveStreamId}/simulcast-targets/${simulcastTargetId}`, options)._thenUnwrap((obj) => obj.data);
    }
    /**
     * Configures a live stream to receive embedded closed captions. The resulting
     * Asset's subtitle text track will have `closed_captions: true` set.
     */
    updateEmbeddedSubtitles(liveStreamId, body, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/embedded-subtitles`, {
            body,
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
    /**
     * Updates a live stream's automatic-speech-recognition-generated subtitle
     * configuration. Automatic speech recognition subtitles can be removed by sending
     * an empty array in the request payload.
     */
    updateGeneratedSubtitles(liveStreamId, body, options) {
        return this._client.put(`/video/v1/live-streams/${liveStreamId}/generated-subtitles`, {
            body,
            ...options,
        })._thenUnwrap((obj) => obj.data);
    }
}
export class LiveStreamsBasePage extends BasePage {
}
(function (LiveStreams) {
    LiveStreams.LiveStreamsBasePage = LiveStreamsAPI.LiveStreamsBasePage;
})(LiveStreams || (LiveStreams = {}));
//# sourceMappingURL=live-streams.mjs.map